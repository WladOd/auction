/*
Immudb Cloud Service

Specification of API to interact with Immudb Cloud Service.

API version: 1.0.0
Contact: contact@codenotary.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package storage

// import (
// 	"bytes"
// 	"context"
// 	"io"
// 	"net/http"
// 	"net/url"
// 	"strings"
// )


// type AuditAPI interface {

// 	/*
// 	AuditDocument Search for audit items for provided document

// 	Search for audit items for provided document

// 	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
// 	@param ledger Explicit ledger name
// 	@param collection Explicit collection name
// 	@param documentId Explicit document ID
// 	@return ApiAuditDocumentRequest
// 	*/
// 	AuditDocument(ctx context.Context, ledger string, collection string, documentId string) ApiAuditDocumentRequest

// 	// AuditDocumentExecute executes the request
// 	//  @return DocumentAuditResponse
// 	AuditDocumentExecute(r ApiAuditDocumentRequest) (*DocumentAuditResponse, *http.Response, error)

// 	/*
// 	DiffDocument Return diff for document revisions

// 	Return diff for document revisions for provided document id

// 	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
// 	@param ledger Explicit ledger name
// 	@param collection Explicit collection name
// 	@param documentId Explicit document ID
// 	@return ApiDiffDocumentRequest
// 	*/
// 	DiffDocument(ctx context.Context, ledger string, collection string, documentId string) ApiDiffDocumentRequest

// 	// DiffDocumentExecute executes the request
// 	//  @return DocumentDiffResponse
// 	DiffDocumentExecute(r ApiDiffDocumentRequest) (*DocumentDiffResponse, *http.Response, error)

// 	/*
// 	GetCurrentState Return current state of immudb ledger

// 	Return current state of immudb ledger

// 	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
// 	@param ledger Explicit ledger name
// 	@return ApiGetCurrentStateRequest
// 	*/
// 	GetCurrentState(ctx context.Context, ledger string) ApiGetCurrentStateRequest

// 	// GetCurrentStateExecute executes the request
// 	//  @return SchemaImmutableState
// 	GetCurrentStateExecute(r ApiGetCurrentStateRequest) (*SchemaImmutableState, *http.Response, error)

// 	/*
// 	GetDocumentProof Return a proof for a document

// 	Return a proof for a document with specified document-id

// 	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
// 	@param ledger Explicit ledger name
// 	@param collection Explicit collection name
// 	@param documentId Explicit document ID
// 	@return ApiGetDocumentProofRequest
// 	*/
// 	GetDocumentProof(ctx context.Context, ledger string, collection string, documentId string) ApiGetDocumentProofRequest

// 	// GetDocumentProofExecute executes the request
// 	//  @return DocumentProofResponse
// 	GetDocumentProofExecute(r ApiGetDocumentProofRequest) (*DocumentProofResponse, *http.Response, error)

// 	/*
// 	GetLedgerDbSize Return ledger DB size

// 	Return ledger DB size

// 	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
// 	@param ledger Explicit ledger name
// 	@return ApiGetLedgerDbSizeRequest
// 	*/
// 	GetLedgerDbSize(ctx context.Context, ledger string) ApiGetLedgerDbSizeRequest

// 	// GetLedgerDbSizeExecute executes the request
// 	//  @return LedgerDBSize
// 	GetLedgerDbSizeExecute(r ApiGetLedgerDbSizeRequest) (*LedgerDBSize, *http.Response, error)
// }

// // AuditAPIService AuditAPI service
// type AuditAPIService service

// type ApiAuditDocumentRequest struct {
// 	ctx context.Context
// 	ApiService AuditAPI
// 	ledger string
// 	collection string
// 	documentId string
// 	documentAuditRequest *DocumentAuditRequest
// }

// func (r ApiAuditDocumentRequest) DocumentAuditRequest(documentAuditRequest DocumentAuditRequest) ApiAuditDocumentRequest {
// 	r.documentAuditRequest = &documentAuditRequest
// 	return r
// }

// func (r ApiAuditDocumentRequest) Execute() (*DocumentAuditResponse, *http.Response, error) {
// 	return r.ApiService.AuditDocumentExecute(r)
// }

// /*
// AuditDocument Search for audit items for provided document

// Search for audit items for provided document

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param ledger Explicit ledger name
//  @param collection Explicit collection name
//  @param documentId Explicit document ID
//  @return ApiAuditDocumentRequest
// */
// func (a *AuditAPIService) AuditDocument(ctx context.Context, ledger string, collection string, documentId string) ApiAuditDocumentRequest {
// 	return ApiAuditDocumentRequest{
// 		ApiService: a,
// 		ctx: ctx,
// 		ledger: ledger,
// 		collection: collection,
// 		documentId: documentId,
// 	}
// }

// // Execute executes the request
// //  @return DocumentAuditResponse
// func (a *AuditAPIService) AuditDocumentExecute(r ApiAuditDocumentRequest) (*DocumentAuditResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPost
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *DocumentAuditResponse
// 	)

// 	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIService.AuditDocument")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/ledger/{ledger}/collection/{collection}/document/{document-id}/audit"
// 	localVarPath = strings.Replace(localVarPath, "{"+"ledger"+"}", url.PathEscape(parameterValueToString(r.ledger, "ledger")), -1)
// 	localVarPath = strings.Replace(localVarPath, "{"+"collection"+"}", url.PathEscape(parameterValueToString(r.collection, "collection")), -1)
// 	localVarPath = strings.Replace(localVarPath, "{"+"document-id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.documentAuditRequest == nil {
// 		return localVarReturnValue, nil, reportError("documentAuditRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.documentAuditRequest
// 	if r.ctx != nil {
// 		// API Key Authentication
// 		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
// 			if apiKey, ok := auth["ApiKeyAuth"]; ok {
// 				var key string
// 				if apiKey.Prefix != "" {
// 					key = apiKey.Prefix + " " + apiKey.Key
// 				} else {
// 					key = apiKey.Key
// 				}
// 				localVarHeaderParams["X-API-Key"] = key
// 			}
// 		}
// 	}
// 	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := a.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 402 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 404 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 500 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiDiffDocumentRequest struct {
// 	ctx context.Context
// 	ApiService AuditAPI
// 	ledger string
// 	collection string
// 	documentId string
// 	documentDiffRequest *DocumentDiffRequest
// }

// func (r ApiDiffDocumentRequest) DocumentDiffRequest(documentDiffRequest DocumentDiffRequest) ApiDiffDocumentRequest {
// 	r.documentDiffRequest = &documentDiffRequest
// 	return r
// }

// func (r ApiDiffDocumentRequest) Execute() (*DocumentDiffResponse, *http.Response, error) {
// 	return r.ApiService.DiffDocumentExecute(r)
// }

// /*
// DiffDocument Return diff for document revisions

// Return diff for document revisions for provided document id

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param ledger Explicit ledger name
//  @param collection Explicit collection name
//  @param documentId Explicit document ID
//  @return ApiDiffDocumentRequest
// */
// func (a *AuditAPIService) DiffDocument(ctx context.Context, ledger string, collection string, documentId string) ApiDiffDocumentRequest {
// 	return ApiDiffDocumentRequest{
// 		ApiService: a,
// 		ctx: ctx,
// 		ledger: ledger,
// 		collection: collection,
// 		documentId: documentId,
// 	}
// }

// // Execute executes the request
// //  @return DocumentDiffResponse
// func (a *AuditAPIService) DiffDocumentExecute(r ApiDiffDocumentRequest) (*DocumentDiffResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPut
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *DocumentDiffResponse
// 	)

// 	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIService.DiffDocument")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/ledger/{ledger}/collection/{collection}/document/{document-id}/audit"
// 	localVarPath = strings.Replace(localVarPath, "{"+"ledger"+"}", url.PathEscape(parameterValueToString(r.ledger, "ledger")), -1)
// 	localVarPath = strings.Replace(localVarPath, "{"+"collection"+"}", url.PathEscape(parameterValueToString(r.collection, "collection")), -1)
// 	localVarPath = strings.Replace(localVarPath, "{"+"document-id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.documentDiffRequest == nil {
// 		return localVarReturnValue, nil, reportError("documentDiffRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.documentDiffRequest
// 	if r.ctx != nil {
// 		// API Key Authentication
// 		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
// 			if apiKey, ok := auth["ApiKeyAuth"]; ok {
// 				var key string
// 				if apiKey.Prefix != "" {
// 					key = apiKey.Prefix + " " + apiKey.Key
// 				} else {
// 					key = apiKey.Key
// 				}
// 				localVarHeaderParams["X-API-Key"] = key
// 			}
// 		}
// 	}
// 	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := a.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 402 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 404 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 500 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiGetCurrentStateRequest struct {
// 	ctx context.Context
// 	ApiService AuditAPI
// 	ledger string
// }

// func (r ApiGetCurrentStateRequest) Execute() (*SchemaImmutableState, *http.Response, error) {
// 	return r.ApiService.GetCurrentStateExecute(r)
// }

// /*
// GetCurrentState Return current state of immudb ledger

// Return current state of immudb ledger

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param ledger Explicit ledger name
//  @return ApiGetCurrentStateRequest
// */
// func (a *AuditAPIService) GetCurrentState(ctx context.Context, ledger string) ApiGetCurrentStateRequest {
// 	return ApiGetCurrentStateRequest{
// 		ApiService: a,
// 		ctx: ctx,
// 		ledger: ledger,
// 	}
// }

// // Execute executes the request
// //  @return SchemaImmutableState
// func (a *AuditAPIService) GetCurrentStateExecute(r ApiGetCurrentStateRequest) (*SchemaImmutableState, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodGet
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *SchemaImmutableState
// 	)

// 	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIService.GetCurrentState")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/ledger/{ledger}/state"
// 	localVarPath = strings.Replace(localVarPath, "{"+"ledger"+"}", url.PathEscape(parameterValueToString(r.ledger, "ledger")), -1)

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	if r.ctx != nil {
// 		// API Key Authentication
// 		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
// 			if apiKey, ok := auth["ApiKeyAuth"]; ok {
// 				var key string
// 				if apiKey.Prefix != "" {
// 					key = apiKey.Prefix + " " + apiKey.Key
// 				} else {
// 					key = apiKey.Key
// 				}
// 				localVarHeaderParams["X-API-Key"] = key
// 			}
// 		}
// 	}
// 	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := a.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 402 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 500 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiGetDocumentProofRequest struct {
// 	ctx context.Context
// 	ApiService AuditAPI
// 	ledger string
// 	collection string
// 	documentId string
// 	documentProofRequest *DocumentProofRequest
// }

// func (r ApiGetDocumentProofRequest) DocumentProofRequest(documentProofRequest DocumentProofRequest) ApiGetDocumentProofRequest {
// 	r.documentProofRequest = &documentProofRequest
// 	return r
// }

// func (r ApiGetDocumentProofRequest) Execute() (*DocumentProofResponse, *http.Response, error) {
// 	return r.ApiService.GetDocumentProofExecute(r)
// }

// /*
// GetDocumentProof Return a proof for a document

// Return a proof for a document with specified document-id

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param ledger Explicit ledger name
//  @param collection Explicit collection name
//  @param documentId Explicit document ID
//  @return ApiGetDocumentProofRequest
// */
// func (a *AuditAPIService) GetDocumentProof(ctx context.Context, ledger string, collection string, documentId string) ApiGetDocumentProofRequest {
// 	return ApiGetDocumentProofRequest{
// 		ApiService: a,
// 		ctx: ctx,
// 		ledger: ledger,
// 		collection: collection,
// 		documentId: documentId,
// 	}
// }

// // Execute executes the request
// //  @return DocumentProofResponse
// func (a *AuditAPIService) GetDocumentProofExecute(r ApiGetDocumentProofRequest) (*DocumentProofResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPost
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *DocumentProofResponse
// 	)

// 	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIService.GetDocumentProof")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/ledger/{ledger}/collection/{collection}/document/{document-id}/proof"
// 	localVarPath = strings.Replace(localVarPath, "{"+"ledger"+"}", url.PathEscape(parameterValueToString(r.ledger, "ledger")), -1)
// 	localVarPath = strings.Replace(localVarPath, "{"+"collection"+"}", url.PathEscape(parameterValueToString(r.collection, "collection")), -1)
// 	localVarPath = strings.Replace(localVarPath, "{"+"document-id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.documentProofRequest == nil {
// 		return localVarReturnValue, nil, reportError("documentProofRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.documentProofRequest
// 	if r.ctx != nil {
// 		// API Key Authentication
// 		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
// 			if apiKey, ok := auth["ApiKeyAuth"]; ok {
// 				var key string
// 				if apiKey.Prefix != "" {
// 					key = apiKey.Prefix + " " + apiKey.Key
// 				} else {
// 					key = apiKey.Key
// 				}
// 				localVarHeaderParams["X-API-Key"] = key
// 			}
// 		}
// 	}
// 	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := a.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 402 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 404 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 500 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiGetLedgerDbSizeRequest struct {
// 	ctx context.Context
// 	ApiService AuditAPI
// 	ledger string
// }

// func (r ApiGetLedgerDbSizeRequest) Execute() (*LedgerDBSize, *http.Response, error) {
// 	return r.ApiService.GetLedgerDbSizeExecute(r)
// }

// /*
// GetLedgerDbSize Return ledger DB size

// Return ledger DB size

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param ledger Explicit ledger name
//  @return ApiGetLedgerDbSizeRequest
// */
// func (a *AuditAPIService) GetLedgerDbSize(ctx context.Context, ledger string) ApiGetLedgerDbSizeRequest {
// 	return ApiGetLedgerDbSizeRequest{
// 		ApiService: a,
// 		ctx: ctx,
// 		ledger: ledger,
// 	}
// }

// // Execute executes the request
// //  @return LedgerDBSize
// func (a *AuditAPIService) GetLedgerDbSizeExecute(r ApiGetLedgerDbSizeRequest) (*LedgerDBSize, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodGet
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *LedgerDBSize
// 	)

// 	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIService.GetLedgerDbSize")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/ledger/{ledger}/size"
// 	localVarPath = strings.Replace(localVarPath, "{"+"ledger"+"}", url.PathEscape(parameterValueToString(r.ledger, "ledger")), -1)

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	if r.ctx != nil {
// 		// API Key Authentication
// 		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
// 			if apiKey, ok := auth["ApiKeyAuth"]; ok {
// 				var key string
// 				if apiKey.Prefix != "" {
// 					key = apiKey.Prefix + " " + apiKey.Key
// 				} else {
// 					key = apiKey.Key
// 				}
// 				localVarHeaderParams["X-API-Key"] = key
// 			}
// 		}
// 	}
// 	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := a.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 402 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 500 {
// 			var v ErrReply
// 			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
// 					newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }
